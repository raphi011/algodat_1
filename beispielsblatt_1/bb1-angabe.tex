\documentclass[a4paper, 12pt]{article}
\usepackage[angabe]{tuwadsa}
\usepackage[normalem]{ulem}
\usepackage{fancyvrb}
\ueblattnr{1}
\uedatum{Abzugeben bis Dienstag, 01.\ April 2014 um 23:59.}
\deadline{Dienstag, 01.04.2014 um 23:59}
\begin{document}
\ueblatt
\setcounter{angabe}{0}
\zugriff{2014}




\begin{angabe}
Die Folge der sogenannten \emph{Fibonacci-Zahlen}
$\langle f_n\rangle = \langle 1, 1, 2, 3, 5, 8, \ldots\rangle$ kann mit
dem folgenden Algorithmus berechnet werden:
\begin{center}
\begin{minipage}{8cm}
\begin{algorithmic}
\item[\texttt{fib(}$n$\texttt):]
\FALLS{$n == 1 \lor n == 2$}
	\ZEILE \textbf{retourniere} 1;
\SONST
	\ZEILE \textbf{retourniere} \texttt{fib(}$n - 1$\texttt)
		${} + {}$
		\texttt{fib(}$n - 2$\texttt);
\ENDFALLS
\end{algorithmic}
\end{minipage}
\end{center}
\begin{itemize}
\item Geben Sie die Anzahl der vorgenommenen rekursiven Aufrufe bei der
	Berechnung von $f_{10}$ 

	\textit{$f_{10}$ benötigt 109 Aufrufe.}
	
\item Geben Sie eine obere Schranke für $f_n$ in $O$-Notation in
	Abhängigkeit von $n$ an und beweisen Sie die Gültigkeit der
	gewählten Schranke. Ist Ihre obere Schranke auch gleichzeitig
	eine untere Schranke?
\item Schreiben Sie einen Algorithmus in detailliertem Pseudocode der
	$f_n$ in $O(n)$ Schritten berechnet.\newline
	

\begin{minipage}{10cm}
\textbf{Algorithmus:} \texttt{fibonacci iterativ(}$~A$\texttt)
\hrule
\begin{algorithmic}
\item[\textbf{Eingabe:}] $n$
\item[\textbf{Rückgabewert:}] $r$ Berechneter fibonacci Wert
\item[{}]
	\FALLS {$n==1$ oder $n==2$}
	    \ZEILE $r = 1$;
	\SONST
		\ZEILE $n1 = 1$
		\ZEILE $n2 = 1$
		\ZEILE $i = 3$
		\SOLANGE {$i<n+1$}
			\ZEILE $n3 = n1 + n2$
			\ZEILE $n1 = n2$
			\ZEILE $n2 = n3$
			\ZEILE $i = i + 1$
		\ENDSOLANGE 
		\ZEILE $r = n2$
	\ENDFALLS
	\ZEILE return $r$;
\end{algorithmic}
\end{minipage}
\end{itemize}
\end{angabe}

\zugriff{2014}




\begin{angabe}
Bestimmen Sie die Laufzeiten der unten angegebenen Algorithmen in
Abhängigkeit von $n$ in $\Theta$-Notation. Verwenden Sie hierfür einen
möglichst einfachen Term.

A \quad
\begin{minipage}[t]{7cm}
\begin{algorithmic}
\ZEILE $a = 10000 * \operatorname{Zufallszahl} \in {1,...,10};$
\SOLANGE {$a > 0$}
  \FUER {$b = 1, \ldots, n/30$}
    \ZEILE $c = 2b;$
  \ENDFUER
  \ZEILE $a = \lfloor a / 2 \rfloor;$
\ENDSOLANGE
\end{algorithmic}
\end{minipage}
\hfill
B \quad
\begin{minipage}[t]{5cm}
\begin{algorithmic}
\ZEILE $i = 1;$
\ZEILE $a = 1;$ 
\WIEDERHOLE
  \ZEILE $i = i * 2;$
  \ZEILE $a = a * a;$
\BIS {$i \geq \log_2 n;$}
\FUER {$j = 0, \ldots, a$}
  \ZEILE $x = x + j;$
\ENDFUER

\end{algorithmic}
\end{minipage}
\end{angabe}

A ) $\Theta(n)$
\newline
B ) $\Theta (ld(ld(n)))$



\zugriff{2014}




\begin{angabe}
Ergänzen Sie die folgenden Algorithmen in beliebiger Weise so, dass sie die angegebenen Laufzeiten
erreichen:

C \quad
\begin{minipage}[t]{5cm}
$\Theta(n^2 \cdot \log_{2}{n})$

\begin{algorithmic}
\FUER{$l = 1, \ldots,n^2$}
        \ZEILE $k = n;$
        \WIEDERHOLE
                \ZEILE $k = \lfloor k / 2 \rfloor$;
                \ZEILE $m = n * k$;
        \BIS {$k \leq 1$}
\ENDFUER
\end{algorithmic}
\end{minipage}
\hfill
D \quad
\begin{minipage}[t]{5cm}
$\Theta(\log^2{n})$

\begin{algorithmic}
\ZEILE $x = \log^2{n};$
\SOLANGE {$x > 1$}
  \ZEILE $y = n^2 - x;$
  \ZEILE $x = x - 1$;
\ENDSOLANGE
\end{algorithmic}
\end{minipage}
\hfill\\[1ex]

\end{angabe}





\zugriff{2014}


\begin{angabe}
Zeigen Sie, dass
\[
10^n = O(n!)
\]
gilt, indem sie konkrete Werte für $n_0$ und $c$ finden, und beweisen,
dass die entsprechenden Ungleichungen mit diesen Konstanten erfüllt werden
können.
\end{angabe}



\zugriff{2014}




\begin{angabe}
Schreiben Sie den Pseudocode f{\"u}r ein neues, rekursives
Sortierverfahren. Der Algorithmus wird mit einer Folge $A$ der Länge
$l$ und zwei Indizes $i$ und $j$ aufgerufen. Es gilt $1\leq i\leq j\leq l$.
Das Prinzip des Algorithmus soll es sein, erst das kleinste Element
in der Teilfolge $A[i]$ bis $A[j]$ an Position $i$ zu bringen und
das größte an Position $j$.  Dann werden die Elemente zwischen $i$
und $j$ rekursiv sortiert, indem der Algorithmus sich selbst
aufruft.  Achten Sie darauf, dass man eine Folge aus einem einzelnen
Element nicht sortieren muss.
\end{angabe}




\zugriff{2014}




\begin{angabe}
Sortieren Sie die unten angegebene Folge von Zahlen \emph{aufsteigend} mit
Hilfe von \emph{Sortieren durch Verschmelzen (Merge-Sort)} und geben Sie die
Zahlenfolge nach jedem kompletten Verschmelzungsschritt an. Markieren Sie (auch
in der Eingabefolge) die jeweiligen Grenzen zwischen den bereits sortierten
Teilfolgen.

\begin{center}
$\langle 14, 3, 5, 12, 7, 2, 19, 12, 1 \rangle $
\end{center}


\end{angabe}

%  c | c |  c | c | c | c | c | c | c
\begin{tabular}{ c  c   c  c  c  c  c  c  c }
$[$14$]$ & $[$3$]$ & $[$5$]$ & $[$12$]$ & $[$7$]$ & $[$2$]$ & $[$19$]$ & $[$12$]$ & $[$1$]$ \\
$[$3 & 14$]$ & $[$5 & 12$]$ & $[$2 & 7$]$ & $[$12 & 19$]$ & $[$1$]$ \\
$[$3 & 5 & 12 & 14$]$ & $[$2 & 7$]$ & $[$1 & 12 & 19$]$ \\
$[$3 & 5 & 12 & 14$]$ & $[$1 & 2 & 7 & 12 & 19$]$ \\
$[$1 & 2 & 3 & 5 & 7 & 12 & 12 & 14 & 19$]$ \\
\end{tabular}


\zugriff{2014}




\begin{angabe}
Sortieren Sie die folgende Zahlenfolge mit Hilfe von \textit{Quicksort}
\[
\langle 111, 11, 1, 1, 110, 111, 1  \rangle.
\]
Schreiben Sie dabei nach jedem Schritt des Algorithmus die entstandene
Zahlenfolge auf und markieren Sie jeweils die aktuellen Pivotelemente,
alle bereits sortierten Elemente und die im jeweiligen Schritt
vertauschten Elemente.

Geben Sie eine beliebige Eingabefolge an, die für Quicksort
(Implementierung laut Skriptum, Pivotlement ist das rechteste Element) 
einen \emph{Worst-Case} bezogen auf die
Anzahl der Schlüsselvergleiche darstellt.  Wie viele Schlüsselbewegungen
und Schlüsselvergleiche, in $\Theta$-Notation in Abhängigkeit der
Eingabegröße $n$, werden für Ihre \emph{Worst-Case} Eingabefolge benötigt?



\end{angabe}

$[.]$ = bereits sortierte Elemente
\newline
$\downarrow$ = vertauschte Elemente
\newline
\underline{1} = pivot Element



\begin{tabular}{ c c c c c c c }
\hline
$\downarrow$ & & & $\downarrow$ & & & \\
111 & 11 & 1 & 1 & 110 & 111 & \underline{1} \\
\hline
 & $\downarrow$ & $\downarrow$ &  & & & \\
1 & 11 & 1 & 111 & 110 & 111 & \underline{1} \\
\hline
 &  & $\downarrow$ &  & & & $\downarrow$\\
1 & 1 & 11 & 111 & 110 & 111 & \underline{1} \\
\hline
 &  &  & $\downarrow$ & & & $\downarrow$\\
1 & \underline{1} & $[$1$]$ & 111 & 110 & 111 & \underline{11} \\
\hline
&  &  &  & & &\\
$[$1 & 1 & 1 & 11$]$ & 110 & 111 & \underline{111} \\
\hline
&  &  &  & & &\\
$[$1 & 1 & 1 & 11$]$ & 110 & \underline{111} & $[$111$]$ \\
\hline
&  &  &  & & &\\
$[$1 & 1 & 1 & 11 & 110 & 111 & 111$]$ \\
\hline


\end{tabular}


	
	
	
Worst-case Beispiel: aufsteigend sortierte Folge
\newline
$\langle 1,2,3,4,5,6,7,8,10  \rangle.$
\newline\newline
$C_{worst}(n)=\Theta(n^2)$ 
\newline
$M_{worst}(n)=\Theta(n*log(n))$ 




\begin{angabe}

\newcommand{\NULL}{\ensuremath{\mathtt{NULL}}}
\newcommand{\aif}{\ensuremath{\mathbf{if}}}
\newcommand{\ret}{\ensuremath{\mathbf{return}}}

Gegeben sei der Algorithmus \texttt{sort(}$A,i$\texttt),
wobei $i$ ein Index im Feld $A$ mit den zu sortierenden Elementen
$A[1] \ldots A[n]$ ist. Der Schlüsselwert eines Elementes $A[i]$ wird
im Attribut $A[i].key$ gespeichert.
Der Algorithmus wird durch den Aufruf \texttt{sort(}$A,n$\texttt)
gestartet.

\bigskip

\begin{minipage}{8.5cm}
\textbf{Algorithmus:} \texttt{sort(var}$~A,i$\texttt)
\hrule
\begin{algorithmic}
\item[\textbf{Eingabe:}] Feld $A$, Index $i$ in Feld $A$
\item[\textbf{Rückgabewert:}] Sortiertes Feld $A$
\item[{}]
	\FALLS {$i>1$}
	    \ZEILE $max = i$;
	    \ZEILE $j=i-1$;
	    \SOLANGE {$j>0$}
	      \FALLS {$A[j].key > A[max].key$}
		  \ZEILE $max=j$;
	      \ENDFALLS
	      \ZEILE $j=j-1$;
	    \ENDSOLANGE
	    \ZEILE $maxelement = A[max]$;
	    \ZEILE $A[max] = A[i]$;
	    \ZEILE $A[i] = maxelement$; 
	    \ZEILE $i = i -1$;
	    \ZEILE $A = sort(A,i)$;
	\ENDFALLS
	\ZEILE return $A$;

\end{algorithmic}
\end{minipage}
\begin{minipage}{6.5cm}
\begin{itemize}
\item Auf welchem aus der Vorlesung bekannten Sortierverfahren
	beruht \texttt{sort()}?

	%\vspace{20mm}

\item
Geben Sie die Laufzeit von \texttt{sort()} im Best- und im Worst-Case in
$\Theta$-Notation in Abhängigkeit der Anzahl der zu sortierenden Element
$n$ an.

\item
Wenden Sie den Algorithmus \texttt{sort()} auf die Zahlenfolge 
$\langle 9, 9, 1, 5, 1\rangle$ an. Geben Sie die Zahlenfolge jeweils bei
dem Aufruf von \texttt{sort()} an.

\item
Wie müssten Sie den Algorithmus abändern, damit die Elemente der
Felder in umgekehrter Reihenfolge sortiert werden?
\end{itemize} 
\end{minipage}

\end{angabe}





\end{document}
